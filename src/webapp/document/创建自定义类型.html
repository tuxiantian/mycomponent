<!doctype html>
<html>
 <head> 
  <meta charset="UTF-8"> 
  <title>创建自定义类型</title>
  <meta name="keywords" content="创建自定义类型"> 
  <link rel="stylesheet" type="text/css" href="${webSiteDomain}/mycomponent/css/common.css"> 
 </head> 
 <body> 
  <article> 
   <p> 组合使用构造函数模式和原型模式 </p> 
   <p> &nbsp;&nbsp;创建自定义类型的最常见模式，就是组合使用构造函数模式与原型模式。构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度的节省了内存。另外这种混成模式还支持向构造函数传递参数；可谓是集两种模式之长。一个示例如下： </p> 
   <p> &nbsp; function Person(name, age, job){ </p> 
   <p> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this.name = name; </p> 
   <p> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this.age = age; </p> 
   <p> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this.job = job; </p> 
   <p> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this.friends = ["Shelby", "Court"]; </p> 
   <p> &nbsp; &nbsp; &nbsp; &nbsp; } </p> 
   <p> &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </p> 
   <p> &nbsp; &nbsp; &nbsp; &nbsp; Person.prototype = { </p> 
   <p> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constructor: Person, </p> 
   <p> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sayName : function () { </p> 
   <p> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; alert(this.name); </p> 
   <p> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } </p> 
   <p> &nbsp; &nbsp; &nbsp; &nbsp; }; </p> 
   <p> &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </p> 
   <p> &nbsp; &nbsp; &nbsp; &nbsp; var person1 = new Person("Nicholas", 29, "Software Engineer"); </p> 
   <p> &nbsp; &nbsp; &nbsp; &nbsp; var person2 = new Person("Greg", 27, "Doctor"); </p> 
   <p> &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </p> 
   <p> &nbsp; &nbsp; &nbsp; &nbsp; person1.friends.push("Van"); </p> 
   <p> &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </p> 
   <p> &nbsp; &nbsp; &nbsp; &nbsp; alert(person1.friends); &nbsp; &nbsp;//"Shelby,Court,Van" </p> 
   <p> &nbsp; &nbsp; &nbsp; &nbsp; alert(person2.friends); &nbsp; &nbsp;//"Shelby,Court" </p> 
   <p> &nbsp; &nbsp; &nbsp; &nbsp; alert(person1.friends === person2.friends); &nbsp;//false </p> 
   <p> &nbsp; &nbsp; &nbsp; &nbsp; alert(person1.sayName === person2.sayName); &nbsp;//true </p> 
   <p> &nbsp; 在这个例子中，实例属性都是在构造函数中定义的，而由所有实例共享的属性constructor和方法sayName()则是在原型中定义的。而修改了person1.friends(向其中添加了一个新字符串)，并不会影响到person2.friends，因为它们分别引用了不同的数组。 </p> 
   <p> &nbsp; 这种构造函数与原型混成的模式，是目前在ECMAScript中使用最广泛、认同度最高的一种创建自定义类型的方法。可以说，这是定义引用类型的一种默认模式。 </p> 
  </article>  
 </body>
</html>